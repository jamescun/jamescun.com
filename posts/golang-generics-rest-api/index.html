<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>REST APIs with Go Generics</title><link rel=stylesheet type=text/css href=https://jamescun.com/sass/main.5cb18835896e46353342724e4f09e666f2a19f7bab9e87603036e3be2469df03.css integrity="sha256-XLGINYluRjUzQnJOTwnmZvKhn3urnodgMDbjviRp3wM="><meta name=url content="https://jamescun.com/posts/golang-generics-rest-api/"><meta name=twitter:url content="https://jamescun.com/posts/golang-generics-rest-api/"><meta property="og:url" content="https://jamescun.com/posts/golang-generics-rest-api/"><meta name=description content="A brief guide on reducing boilerplate when writing REST APIs with Go and Generics."></head><body><header class=main><h1><a href=/>James Cunningham</a></h1><nav><a href=/posts>Blog</a>
<a href=https://github.com/jamescun>GitHub</a>
<a href=https://twitter.com/jamescun>Twitter</a>
<a href=https://www.linkedin.com/in/james-cunningham-58339113/>LinkedIn</a></nav></header><article class=post><header><h1 class=title><a href=https://jamescun.com/posts/golang-generics-rest-api/>REST APIs with Go Generics</a></h1><span class=meta>March 2022</span></header><p>We&rsquo;re on the verge of Go 1.18 being released, with the headline feature of Generics going mainstream after many years of discussion. But what are generics?</p><p>I am primarily involved in the development of networked services. These consist of a mixture of HTTP REST and gRPC services. A nice element of working with a gRPC service is the method signature of your endpoints are generated for you, you simply provide the implementation. We have no such thing for the HTTP REST services.</p><p>Do we replicate the code generation benefits of gRPC, but for the HTTP REST services? Or, could we use generics?</p><p>Consider a hypothetical service that generates friendly greetings for users, it may define an request and response structure, accepting a name and returning the greeting:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>GreetRequest</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;name&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>GreetResponse</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Greeting</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;greeting&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If we continue with principles derived from gRPC, the ideal method signature of the function handling this request may look something like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Greet</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>GreetRequest</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>GreetResponse</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>GreetRes</span>{<span style=color:#a6e22e>Greeting</span>: <span style=color:#e6db74>&#34;Hello &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>Name</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;!&#34;</span>}, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However the above does not conform to any of interfaces and types routinely expected by HTTP routers, in particular <code>http.Handler</code> and <code>http.HandlerFunc</code>.</p><p>Prior to Go 1.18 and Generics, you are left with two options: write glue logic for every one of your API endpoints or use runtime reflection and empty interfaces, to adapt your endpoint to your chosen router.</p><p>Now with generics, we can implement a function that can wrap any function implementing a similar method signature into a JSON API, inheriting the compile-time type safety of Go. What might that look like? Consider the following generic function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>JSON</span>[<span style=color:#a6e22e>REQ</span>, <span style=color:#a6e22e>RES</span> <span style=color:#a6e22e>any</span>](<span style=color:#a6e22e>fn</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>REQ</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>RES</span>, <span style=color:#66d9ef>error</span>)) <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandlerFunc</span>
</span></span></code></pre></div><p>Let&rsquo;s analyze what we just did.</p><p>The first obvious difference is the square brackets, these identify to the compiler we are writing a generic function. Specifically, what are the names and the types the compiler will substitute in our generic function for each instance we use our generic function. <code>REQ</code> and <code>RES</code> correspond to our request and response structures, but can be anything.</p><p>However we can now implement the rest of our function as we otherwise would, except using <code>REQ</code> and <code>RES</code> in place of our actual request and response structures. In a simplified implementation, let&rsquo;s unmarshal JSON from the HTTP request, execute our endpoint&rsquo;s function and marshal JSON back to the HTTP client:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>req</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>REQ</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>NewDecoder</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Body</span>).<span style=color:#a6e22e>Decode</span>(<span style=color:#a6e22e>req</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fn</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Context</span>(), <span style=color:#a6e22e>req</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// handle error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>NewEncoder</span>(<span style=color:#a6e22e>w</span>).<span style=color:#a6e22e>Encode</span>(<span style=color:#a6e22e>res</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s it. Our generic <code>JSON</code> function can be used to adapt any of our API endpoint functions to our HTTP router. i.e.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>router</span>.<span style=color:#a6e22e>Post</span>(<span style=color:#e6db74>&#34;/v1/greeting&#34;</span>, <span style=color:#a6e22e>JSON</span>(<span style=color:#a6e22e>Greet</span>))
</span></span></code></pre></div><p>And now, assuming everything is correct, calling the endpoint, we are greeted with the expected response:</p><pre tabindex=0><code>POST /1/greeting HTTP/1.1
{&#34;name&#34;: &#34;James&#34;}

HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{&#34;greeting&#34;: &#34;Hello James!&#34;}
</code></pre><p>This post only scratches the surface of where Go Generics can help us reduce repetition and introduce compile-time type safety to our code. I will continue expanding on this example in future blog posts on how we can use Go Generics to improve building APIs.</p></article><footer class=main>&copy; 2023 James Cunningham. <a href=https://github.com/jamescun/jamescun.com>Source</a>.</footer></body></html>