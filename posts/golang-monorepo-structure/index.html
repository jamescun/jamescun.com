<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>Go Monorepos for Growing Teams</title><link rel=stylesheet type=text/css href=/style.css></head><body><header class=main><h1><a href=/>James Cunningham</a></h1><nav><a href=/posts>Blog</a>
<a href=https://github.com/jamescun>GitHub</a>
<a href=https://twitter.com/jamescun>Twitter</a>
<a href=https://www.linkedin.com/in/james-cunningham-58339113/>LinkedIn</a></nav></header><article class=post><header><h1><a href=https://jamescun.com/posts/golang-monorepo-structure/>Go Monorepos for Growing Teams</a></h1><span class=meta>Published: 2022-08-22</span></header><p>I&rsquo;ve been working with Go monorepos and microservices for longer than I care to admit. I&rsquo;ve seen a lot written about how to get started with them, but never anything from the trenches. You have a monorepo of microservices, great, what next?</p><p>I won&rsquo;t go into what monorepos or microservices are, or what they pros and cons of each are, as that has been written about at length by people better qualified than me. Instead, I will dive into how I&rsquo;ve previously solved some of the problems of Go monorepo growth.</p><h1 id=single-team-multiple-services>Single Team, Multiple Services</h1><p>Starting with the simple scenario, a small engineering team operates a monorepo consisting of Go microservices. Everyone can work on everything, mental context is readily shared and project teams are fluid. Everybody understands the system end-to-end, and what APIs are where.</p><p>If this sounds familiar, you may feel at home in the directory structure below:</p><img src=/img/stage-one-monorepo.png width=393><p>I know I do, my last three jobs started their monorepo adventures similarly.</p><p>Going from the root, <code>pkg</code> contains packages that are intended to be shared between services, and <code>svc</code> containing microservices. Each microservice may have it&rsquo;s own <code>pkg</code> directory to split up it&rsquo;s own logic, but should not be consumed by any other microservice.</p><p>Pretty easy to understand and pick up for a new engineer.</p><p>However, does this scale? What happens when we grow the team, when no single engineer can maintain a clear picture of every microservice, or specialized domains develop?</p><h1 id=multiple-teams-multiple-services>Multiple Teams, Multiple Services</h1><p>To mitigate the aforementioned problems, we introduce a layer of indirection, the <code>prj</code> hierarchy (short for &ldquo;projects&rdquo;, we are dealing with Go import paths here!) containing a sub-hierarchy relating to a team or project.</p><img src=/img/stage-two-monorepo.png width=900><p>With this above structure, we logically group shared packages and microservices into the team or project that owns that area of your system. Examples could be a platform team, who owns your identity or authorization subsystems, or projects like an additional product and it&rsquo;s subsystems.</p><p>You may notice a curious new addition, the <code>proto</code> directory to each team. This may vary depending on what RPC framework you use, if any, but in this instance we are talking Protobuf, and specifically gRPC. This is every <em><strong>other</strong></em> team&rsquo;s gateway into yours. It is the contract you define with your wider engineering team about what you are going to provide them.</p><p>In combination with the review process in your monorepo, this creates a healthy team practice where you and your stakeholders can collaborate on API design. Other teams do not need to know which of your microservices handles what logic, just that the API they expect from you is available at <code>monorepo/prj/yourteam/proto/...</code> and your service mesh/service discovery/gateway/etc will handle the rest.</p><p>You also may notice we left a <code>pkg</code> directory at the root of the monorepo. While each project or team directory has it&rsquo;s own <code>pkg</code> directory as described previously, there will be some logic that is common to all teams or projects, for example, secrets management or service discovery. It is important to tightly scope the top-level <code>pkg</code> directory to this purpose, only elevating from project/team <code>pkg</code> directories when a clear need is defined.</p><p>And finally, while the purpose of this blog post isn&rsquo;t to talk about continuous deployment, if you are automatically redeploying all services for every change, which I&rsquo;ve seen frequently in the Single Team scenario, breaking your codebase down by team or project could be the first step towards independent service deployments.</p><h1 id=tradeoffs>Tradeoffs</h1><h2 id=import-paths>Import Paths</h2><p>While we&rsquo;ve taken care to keep our Go package import paths short with abbreviations, those abbreviations introduce additional mental context that needs to be communicated to new engineers, and only partially solves the problem.</p><h2 id=go-modules>Go Modules</h2><p>Where this model breaks down is dependency management with Go modules, whether Single or Multiple Team. Currently, to support this structure, the monorepo must share a single <code>go.mod</code> file at the root.</p><p>This can be painful as it introduces a point of contention when introducing or upgrading dependencies.</p><p>Since Go 1.18, <a href=https://go.dev/blog/get-familiar-with-workspaces>Workspaces</a> introduced support for multiple modules, which sounds like it could help, but I&rsquo;ve not had an opportunity to evaluate them yet.</p></article><footer>&copy; 2023 James Cunningham. <a href=https://github.com/jamescun/jamescun.com>Source</a>.</footer></body></html>